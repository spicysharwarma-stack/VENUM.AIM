--[[
    🐍 Venom Reptile v7.5 - Ultimate Premium Edition
    Next-Gen Threat Assessment & Targeting System
    Universal Xeno Executor Version - Fully Optimized
    REALISTIC THREAT SYSTEM - PERFECT STEALTH/COMBAT DETECTION
    PREMIUM VISUALS & SMOOTH PERFORMANCE
]]

-- Services
local Camera = workspace.CurrentCamera
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer
local Mouse = LocalPlayer:GetMouse()

-- Premium Configuration
local Settings = {
    Enabled = true,
    TeamCheck = false,
    AimPart = "Head",
    Sensitivity = 0.06,
    FOV = {
        Radius = 130,
        Color = Color3.fromRGB(0, 255, 180),
        Transparency = 0.7,
        Filled = false,
        Visible = true,
        Thickness = 2,
        Sides = 64
    },
    VisibilityCheck = true,
    MaxDistance = 2500,
    Prediction = {
        Enabled = true,
        Strength = 0.165,
        VerticalAdjustment = 0.05
    },
    Highlight = {
        Enabled = true,
        Color = Color3.fromRGB(255, 223, 0)
    },
    Humanizer = {
        Enabled = true,
        Intensity = 0.3,
        MissChance = 0.15,
        MissCooldown = 0.5,
        BodyPartRandomization = 0.7
    },
    SmartSwitch = {
        Enabled = true,
        ThreatEvaluationInterval = 0.3,
        TargetLockDuration = 1.8,
        TargetSwitchCooldown = 0.5,
        MinThreatDifference = 25,
        RecentTargetBonus = 15
    },
    Radar = {
        Enabled = true,
        Size = 120,
        Range = 300,
        BackgroundTransparency = 0.8,
        Position = UDim2.new(1, -140, 1, -140),
        RefreshRate = 0.2
    },
    FOVChangeOnAim = true,
    AimKey = Enum.UserInputType.MouseButton2,
    ToggleKey = Enum.KeyCode.F,
    
    -- Enhanced threat evaluation settings
    CloseRangePriority = 120,
    ImmediateThreatBonus = 80,
    RecentTargetMemory = 3,
    
    -- Revised threat evaluation factors
    FacingPlayerBonus = 40,
    HighGroundBonus = 15,
    WeaponThreatMultiplier = 1.5,
    VisibleTargetBonus = 50,
    
    -- New threat evaluation factors
    DamageDealtBonus = 30,
    MovementThreatFactor = 0.8,
    RecentCombatMemory = 5,
    
    -- Enhanced Playstyle adaptation settings
    PlaystyleAdaptation = {
        Enabled = true,
        AggressionThreshold = 70,
        StealthTime = 10,
        RecentTargetWeight = 0.7,
        LearningRate = 0.1,
        EngagementDistanceWeight = 0.3,
        TargetSwitchFrequencyWeight = 0.2,
        AccuracyBasedAdaptation = true,
        MinEngagementDistance = 50,
        MaxEngagementDistance = 200,
        CloseQuartersBonus = 25,
        LongRangePenalty = 15,
        DetectionThreshold = 0.4, -- How visible player must be to be detected
        StealthEngagementBonus = 35, -- Bonus when engaging from stealth
        CombatCooldown = 3 -- Time after combat ends to return to stealth
    },
    
    -- Enhanced Adaptive FOV settings
    DynamicFOVSettings = {
        Enabled = true,
        BaseFOV = 130,
        PerformanceScaling = true,
        EngagementScaling = true,
        MinFOV = 80,
        MaxFOV = 200,
        StealthFOV = 120,
        CombatFOV = 140,
        TransitionSmoothness = 0.1
    },
    
    -- Premium features
    SoundEffects = false,
    KillConfirmation = true,
    AdvancedVisuals = true,
    DynamicFOV = true
}

-- State Management
local Holding = false
local Target = nil
local LastTargetTime = 0
local threatLabel
local radarFrame
local radarDots = {}
local lastMissTime = 0
local lastHumanizerUpdate = 0
local recentTargets = {}
local lastRadarUpdate = 0
local lastTargetSwitch = 0
local targetLockTime = 0
local currentFOV = Settings.FOV.Radius
local combatEvents = {}
local lastDamageTaken = 0
local damageSource = nil

-- Playstyle tracking
local playstyleMetrics = {
    isStealthMode = true,
    lastCombatTime = 0,
    averageEngagementDistance = 100,
    engagementCount = 0,
    targetSwitchFrequency = 0,
    recentTargets = {},
    preferredTargets = {},
    weaponUsage = {},
    accuracyStats = {
        shotsFired = 0,
        shotsHit = 0,
        lastAccuracyUpdate = 0
    },
    detectionLevel = 0, -- How detected the player is (0-1)
    lastMovementUpdate = 0,
    movementPattern = "stationary",
    lastShotTime = 0,
    combatActions = 0
}

-- Performance tracking
local lastFPSUpdate = 0
local frameCount = 0
local currentFPS = 60

-- Premium Color Scheme
local PremiumColors = {
    Primary = Color3.fromRGB(0, 255, 180),    -- Vibrant teal
    Secondary = Color3.fromRGB(0, 200, 150),  -- Muted teal
    Accent = Color3.fromRGB(255, 223, 0),     -- Gold
    Dark = Color3.fromRGB(15, 25, 22),        -- Dark background
    Light = Color3.fromRGB(170, 255, 236),    -- Light teal
    Danger = Color3.fromRGB(255, 80, 80),     -- Red for danger
    Success = Color3.fromRGB(0, 255, 180),    -- Teal for success
    Elite = Color3.fromRGB(180, 70, 255),     -- Purple for elite
    Background = Color3.fromRGB(20, 30, 27),  -- Darker background
    Panel = Color3.fromRGB(25, 40, 35)        -- Panel background
}

-- FOV Circle with premium effects
local FOVCircle = Drawing.new("Circle")
FOVCircle.Position = Vector2.new(Camera.ViewportSize.X / 2, Camera.ViewportSize.Y / 2)
FOVCircle.Radius = Settings.FOV.Radius
FOVCircle.Filled = Settings.FOV.Filled
FOVCircle.Color = PremiumColors.Primary
FOVCircle.Visible = Settings.FOV.Visible
FOVCircle.Transparency = Settings.FOV.Transparency
FOVCircle.NumSides = Settings.FOV.Sides
FOVCircle.Thickness = Settings.FOV.Thickness

-- Premium Target Indicator with animation
local TargetIndicator = Drawing.new("Circle")
TargetIndicator.Visible = false
TargetIndicator.Radius = 12
TargetIndicator.Filled = true
TargetIndicator.Color = PremiumColors.Accent
TargetIndicator.Transparency = 0.6
TargetIndicator.Thickness = 2

-- Elite target lock indicator
local LockIndicator = Drawing.new("Circle")
LockIndicator.Visible = false
LockIndicator.Radius = 18
LockIndicator.Filled = false
LockIndicator.Color = PremiumColors.Elite
LockIndicator.Transparency = 0.8
LockIndicator.Thickness = 3

-- Performance Optimization
local cachedPlayers = {}
local lastPlayerUpdate = 0
local playerUpdateInterval = 1

-- Calculate player accuracy
local function CalculatePlayerAccuracy()
    if playstyleMetrics.accuracyStats.shotsFired == 0 then
        return 0.5 -- Default accuracy if no shots fired
    end
    
    local accuracy = playstyleMetrics.accuracyStats.shotsHit / playstyleMetrics.accuracyStats.shotsFired
    return math.clamp(accuracy, 0.1, 0.95) -- Keep within reasonable bounds
end

-- Track accuracy when targets are hit
local function TrackAccuracy(hit)
    local currentTime = tick()
    
    playstyleMetrics.accuracyStats.shotsFired = playstyleMetrics.accuracyStats.shotsFired + 1
    
    if hit then
        playstyleMetrics.accuracyStats.shotsHit = playstyleMetrics.accuracyStats.shotsHit + 1
    end
    
    -- Reset accuracy stats periodically to adapt to changing situations
    if currentTime - playstyleMetrics.accuracyStats.lastAccuracyUpdate > 30 then
        playstyleMetrics.accuracyStats.shotsFired = playstyleMetrics.accuracyStats.shotsFired * 0.5
        playstyleMetrics.accuracyStats.shotsHit = playstyleMetrics.accuracyStats.shotsHit * 0.5
        playstyleMetrics.accuracyStats.lastAccuracyUpdate = currentTime
    end
end

-- REALISTIC Playstyle Detection System
local function UpdatePlaystyleMetrics()
    local currentTime = tick()
    local character = LocalPlayer.Character
    
    -- Update movement pattern detection
    if character then
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if rootPart then
            local speed = rootPart.Velocity.Magnitude
            
            if speed < 2 then
                playstyleMetrics.movementPattern = "stationary"
                playstyleMetrics.detectionLevel = math.max(0, playstyleMetrics.detectionLevel - 0.05)
            elseif speed < 10 then
                playstyleMetrics.movementPattern = "walking"
                playstyleMetrics.detectionLevel = math.min(1, playstyleMetrics.detectionLevel + 0.02)
            else
                playstyleMetrics.movementPattern = "running"
                playstyleMetrics.detectionLevel = math.min(1, playstyleMetrics.detectionLevel + 0.08)
            end
            
            playstyleMetrics.lastMovementUpdate = currentTime
        end
    end
    
    -- Check if we're actively in combat (recent shots or damage)
    local timeSinceCombat = currentTime - playstyleMetrics.lastCombatTime
    local timeSinceLastShot = currentTime - playstyleMetrics.lastShotTime
    
    -- REALISTIC COMBAT DETECTION:
    -- Only enter combat if actively shooting, taking damage, or locked onto a target for extended period
    local isInCombat = false
    
    -- If we've shot recently or taken damage
    if timeSinceLastShot < 2 or timeSinceCombat < 2 then
        isInCombat = true
        playstyleMetrics.combatActions = playstyleMetrics.combatActions + 1
    end
    
    -- If we're locked onto a target and actively engaging
    if Holding and Target and currentTime - targetLockTime > 1 then
        isInCombat = true
        playstyleMetrics.detectionLevel = math.min(1, playstyleMetrics.detectionLevel + 0.1)
    end
    
    -- If we've performed multiple combat actions recently
    if playstyleMetrics.combatActions > 3 and timeSinceCombat < 5 then
        isInCombat = true
    end
    
    -- Gradually reduce combat actions over time
    if currentTime % 5 < 0.1 then
        playstyleMetrics.combatActions = math.max(0, playstyleMetrics.combatActions - 1)
    end
    
    -- Set stealth mode based on combat status and detection level
    playstyleMetrics.isStealthMode = not isInCombat and 
        playstyleMetrics.detectionLevel < Settings.PlaystyleAdaptation.DetectionThreshold
    
    -- Update target switch frequency
    if Target and currentTime - lastTargetSwitch < 2 then
        local switchWeight = 0.1
        playstyleMetrics.targetSwitchFrequency = playstyleMetrics.targetSwitchFrequency * (1 - switchWeight) + switchWeight
    else
        playstyleMetrics.targetSwitchFrequency = playstyleMetrics.targetSwitchFrequency * 0.99
    end
end

-- Enhanced playstyle adaptation with realistic threat assessment
local function ApplyPlaystyleAdaptation(threatScore, player, isVisible, distance)
    if not Settings.PlaystyleAdaptation.Enabled then return threatScore end
    
    UpdatePlaystyleMetrics()
    
    -- In stealth mode, prioritize stealthy engagement
    if playstyleMetrics.isStealthMode then
        -- Bonus for targets that haven't detected us
        if not isVisible or distance > 100 then
            threatScore = threatScore + Settings.PlaystyleAdaptation.StealthEngagementBonus
        end
        
        -- Reduce threat for targets that are looking at us (more dangerous in stealth)
        local character = player.Character
        if character then
            local head = character:FindFirstChild("Head")
            local rootPart = character:FindFirstChild("HumanoidRootPart")
            local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
            
            if head and rootPart and localRoot then
                local directionToPlayer = (localRoot.Position - rootPart.Position).Unit
                local lookDirection = head.CFrame.LookVector
                local dotProduct = directionToPlayer:Dot(lookDirection)
                
                -- If target is looking at us, increase threat (they've detected us)
                if dotProduct > 0.8 then
                    threatScore = threatScore * 1.3
                    playstyleMetrics.detectionLevel = math.min(1, playstyleMetrics.detectionLevel + 0.2)
                end
            end
        end
    else
        -- In combat mode, prioritize immediate threats
        if threatScore > Settings.PlaystyleAdaptation.AggressionThreshold then
            threatScore = threatScore * 1.2
        end
        
        -- Bonus for targets that are shooting at us
        if combatEvents[player] and combatEvents[player].Time > tick() - 2 then
            threatScore = threatScore + 40
        end
    end
    
    -- Distance-based adaptation
    if distance < Settings.PlaystyleAdaptation.MinEngagementDistance then
        threatScore = threatScore + Settings.PlaystyleAdaptation.CloseQuartersBonus
    elseif distance > Settings.PlaystyleAdaptation.MaxEngagementDistance then
        threatScore = threatScore - Settings.PlaystyleAdaptation.LongRangePenalty
    end
    
    -- Accuracy-based adaptation
    if Settings.PlaystyleAdaptation.AccuracyBasedAdaptation then
        local accuracyFactor = CalculatePlayerAccuracy()
        threatScore = threatScore * (0.8 + accuracyFactor * 0.4)
    end
    
    -- Adjust based on player's preferred targets (learning)
    if playstyleMetrics.preferredTargets[player] then
        local preferenceBonus = playstyleMetrics.preferredTargets[player] * 0.5
        threatScore = threatScore + preferenceBonus
    end
    
    return threatScore
end

-- Advanced Adaptive FOV System
local function UpdateAdaptiveFOV()
    if not Settings.DynamicFOV or not Settings.DynamicFOVSettings.Enabled then 
        FOVCircle.Radius = Settings.FOV.Radius
        return 
    end
    
    local targetFOV = Settings.DynamicFOVSettings.BaseFOV
    
    -- Performance-based scaling
    if Settings.DynamicFOVSettings.PerformanceScaling then
        local fpsFactor = math.clamp(currentFPS / 60, 0.5, 1.5)
        targetFOV = targetFOV * fpsFactor
    end
    
    -- Engagement distance scaling
    if Settings.DynamicFOVSettings.EngagementScaling and playstyleMetrics.averageEngagementDistance > 0 then
        local distanceFactor = math.clamp(playstyleMetrics.averageEngagementDistance / 100, 0.7, 1.5)
        targetFOV = targetFOV * distanceFactor
    end
    
    -- Playstyle-based scaling
    if playstyleMetrics.isStealthMode then
        targetFOV = Settings.DynamicFOVSettings.StealthFOV
    else
        targetFOV = Settings.DynamicFOVSettings.CombatFOV
    end
    
    -- Apply limits
    targetFOV = math.clamp(targetFOV, Settings.DynamicFOVSettings.MinFOV, Settings.DynamicFOVSettings.MaxFOV)
    
    -- Smooth transition
    local smoothness = Settings.DynamicFOVSettings.TransitionSmoothness or 0.1
    FOVCircle.Radius = FOVCircle.Radius + (targetFOV - FOVCircle.Radius) * smoothness
end

-- Improved Prediction Engine
local function CalculatePrediction(targetChar, aimPart)
    if not Settings.Prediction.Enabled then return aimPart.Position end
    
    local humanoidRootPart = targetChar:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return aimPart.Position end
    
    local velocity = humanoidRootPart.Velocity
    local distance = (aimPart.Position - Camera.CFrame.Position).Magnitude
    
    -- More accurate travel time calculation
    local travelTime = distance / 1200
    
    -- Better prediction formula with vertical adjustment
    local predictedPos = aimPart.Position + velocity * travelTime * Settings.Prediction.Strength
    
    -- Add slight vertical adjustment for more natural aiming
    predictedPos = predictedPos + Vector3.new(0, Settings.Prediction.VerticalAdjustment, 0)
    
    return predictedPos
end

-- Enhanced body part selection with improved hit probability
local function GetRandomizedAimPart(character)
    if not Settings.Humanizer.Enabled or math.random() > Settings.Humanizer.BodyPartRandomization then
        return character:FindFirstChild(Settings.AimPart) or character:FindFirstChild("Head")
    end
    
    -- Smart body part selection with hit probability optimization
    local parts = {
        {Name = "Head", Weight = 45, Offset = Vector3.new(0, -0.2, 0)},
        {Name = "UpperTorso", Weight = 30, Offset = Vector3.new(0, 0.3, 0)},
        {Name = "HumanoidRootPart", Weight = 15, Offset = Vector3.new(0, 0, 0)},
        {Name = "LowerTorso", Weight = 10, Offset = Vector3.new(0, 0, 0)}
    }
    
    local totalWeight = 0
    for _, partData in ipairs(parts) do
        if character:FindFirstChild(partData.Name) then
            totalWeight = totalWeight + partData.Weight
        end
    end
    
    local randomValue = math.random(1, totalWeight)
    local cumulativeWeight = 0
    
    for _, partData in ipairs(parts) do
        local part = character:FindFirstChild(partData.Name)
        if part then
            cumulativeWeight = cumulativeWeight + partData.Weight
            if randomValue <= cumulativeWeight then
                return part, partData.Offset
            end
        end
    end
    
    return character:FindFirstChild("Head") or character:FindFirstChild("UpperTorso"), Vector3.new(0, -0.2, 0)
end

-- Enhanced Humanizer with improved aiming logic
local function ApplyHumanizer(targetPosition, currentTime, targetChar, aimPart)
    if not Settings.Humanizer.Enabled then return targetPosition end
    
    -- Only update humanizer effects periodically for performance
    if currentTime - lastHumanizerUpdate < 0.05 then return targetPosition end
    lastHumanizerUpdate = currentTime
    
    -- Check if we should miss this shot
    if Settings.Humanizer.MissChance > 0 and currentTime - lastMissTime > Settings.Humanizer.MissCooldown then
        if math.random() < Settings.Humanizer.MissChance then
            lastMissTime = currentTime
            -- Add significant offset to simulate a miss
            local missOffset = Vector3.new(
                (math.random() - 0.5) * 5,
                (math.random() - 0.5) * 5,
                (math.random() - 0.5) * 3
            )
            TrackAccuracy(false)
            return targetPosition + missOffset
        end
    end
    
    -- Apply part-specific aiming adjustments
    if aimPart and aimPart.Name == "Head" then
        targetPosition = targetPosition - Vector3.new(0, math.random() * 0.4 + 0.2, 0)
    elseif aimPart and aimPart.Name == "UpperTorso" then
        targetPosition = targetPosition + Vector3.new(0, math.random() * 0.3 - 0.15, 0)
    end
    
    -- Normal humanizer slight movement
    local sineWave = math.sin(currentTime * 5) * Settings.Humanizer.Intensity * 0.3
    local cosineWave = math.cos(currentTime * 4) * Settings.Humanizer.Intensity * 0.2
    
    local microShake = Vector3.new(
        (math.random() - 0.5 + sineWave) * Settings.Humanizer.Intensity * 0.4,
        (math.random() - 0.5 + cosineWave) * Settings.Humanizer.Intensity * 0.4,
        (math.random() - 0.5) * Settings.Humanizer.Intensity * 0.2
    )
    
    TrackAccuracy(true)
    return targetPosition + microShake
end

-- Optimized Visibility Check
local function IsVisible(character)
    if not Settings.VisibilityCheck then return true end
    
    local aimPart = character:FindFirstChild(Settings.AimPart) or character:FindFirstChild("Head")
    if not aimPart then return false end
    
    local origin = Camera.CFrame.Position
    local destination = aimPart.Position
    local direction = (destination - origin).Unit
    
    local raycastParams = RaycastParams.new()
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist
    raycastParams.FilterDescendantsInstances = {LocalPlayer.Character, Camera}
    raycastParams.IgnoreWater = true
    
    local result = workspace:Raycast(origin, direction * Settings.MaxDistance, raycastParams)
    
    if result and result.Instance then
        local hitModel = result.Instance:FindFirstAncestorWhichIsA("Model")
        return hitModel == character
    end
    
    return false
end

-- Efficient Player Cache System
local function UpdatePlayerCache()
    if tick() - lastPlayerUpdate < playerUpdateInterval then return end
    
    cachedPlayers = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            table.insert(cachedPlayers, player)
        end
    end
    
    lastPlayerUpdate = tick()
end

-- Track combat events for threat assessment
local function RecordCombatEvent(attacker, damage)
    local currentTime = tick()
    combatEvents[attacker] = {
        Time = currentTime,
        Damage = damage,
        ThreatLevel = math.min(100, damage * 2)
    }
    
    -- Update combat time for playstyle tracking
    playstyleMetrics.lastCombatTime = currentTime
    playstyleMetrics.combatActions = playstyleMetrics.combatActions + 2
end

-- Clean up old combat events
local function CleanCombatEvents()
    local currentTime = tick()
    for attacker, event in pairs(combatEvents) do
        if currentTime - event.Time > Settings.RecentCombatMemory then
            combatEvents[attacker] = nil
        end
    end
end

-- Advanced threat evaluation system
local lastThreatEvaluation = 0
local function EvaluateThreatLevel(player)
    local character = player.Character
    if not character then return 0 end
    
    local threatScore = 0
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    
    if not rootPart or not humanoid or humanoid.Health <= 0 then return 0 end
    
    -- Distance factor (closer = more threat)
    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
    threatScore = threatScore + (2000 / math.max(1, distance))
    
    -- EXTREME priority for very close targets
    if distance < 25 then
        threatScore = threatScore + Settings.CloseRangePriority
    end
    
    -- Visibility bonus (HIGH priority)
    local isVisible = IsVisible(character)
    if isVisible then
        threatScore = threatScore + Settings.VisibleTargetBonus
        
        -- Additional bonus if target is actively facing and likely engaging you
        local head = character:FindFirstChild("Head")
        if head then
            local directionToPlayer = (Camera.CFrame.Position - rootPart.Position).Unit
            local lookDirection = head.CFrame.LookVector
            local dotProduct = directionToPlayer:Dot(lookDirection)
            
            -- Bonus if player is facing you (more dangerous)
            if dotProduct > 0.7 then
                threatScore = threatScore + Settings.FacingPlayerBonus
                
                -- Immediate threat bonus if very close and facing you
                if distance < 35 and dotProduct > 0.9 then
                    threatScore = threatScore + Settings.ImmediateThreatBonus
                end
            end
        end
    elseif distance > 150 then
        -- Reduce threat for targets beyond anticipation range and not visible
        threatScore = threatScore * 0.6
    end
    
    -- High ground advantage/disadvantage (REDUCED importance)
    local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if localRoot then
        local elevationDifference = rootPart.Position.Y - localRoot.Position.Y
        if elevationDifference > 5 then
            threatScore = threatScore + Settings.HighGroundBonus
        elseif elevationDifference < -5 then
            threatScore = threatScore - 10
        end
    end
    
    -- Weapon detection with multiplier
    local tool = character:FindFirstChildOfClass("Tool")
    if tool then
        threatScore = threatScore * Settings.WeaponThreatMultiplier
    end
    
    -- Recent combat events (damage dealt to you)
    CleanCombatEvents()
    if combatEvents[player] then
        threatScore = threatScore + combatEvents[player].ThreatLevel
    end
    
    -- Movement-based threat reduction (stationary targets are less threatening)
    local speed = rootPart.Velocity.Magnitude
    if speed < 2 then
        threatScore = threatScore * Settings.MovementThreatFactor
    end
    
    -- Recent target memory (anticipate targets that were recently visible)
    local currentTime = tick()
    if recentTargets[player] then
        local timeSinceLastSeen = currentTime - recentTargets[player]
        if timeSinceLastSeen < Settings.RecentTargetMemory then
            threatScore = threatScore + (40 * (1 - timeSinceLastSeen / Settings.RecentTargetMemory))
        end
    end
    
    -- Health-based threat (weaker targets are less threatening)
    local healthPercent = humanoid.Health / humanoid.MaxHealth
    threatScore = threatScore * (0.5 + healthPercent * 0.5)
    
    -- Apply playstyle adaptation
    threatScore = ApplyPlaystyleAdaptation(threatScore, player, isVisible, distance)
    
    return math.max(0, threatScore)
end

-- Enhanced target selection with smart switching
local function FindOptimalTarget()
    UpdatePlayerCache()
    
    local bestTarget = nil
    local highestThreat = -1
    local currentTime = tick()
    
    -- Clean up old recent targets
    for player, lastSeen in pairs(recentTargets) do
        if currentTime - lastSeen > Settings.RecentTargetMemory then
            recentTargets[player] = nil
        end
    end
    
    -- Target lock logic - keep current target if within lock duration
    if Target and Target.Character and currentTime - targetLockTime < Settings.SmartSwitch.TargetLockDuration then
        local character = Target.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and humanoid.Health > 0 and rootPart then
            local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
            if distance <= Settings.MaxDistance and (not Settings.VisibilityCheck or IsVisible(character)) then
                return Target  -- Keep current target during lock period
            end
        end
    end
    
    -- Prevent rapid target switching
    if currentTime - lastTargetSwitch < Settings.SmartSwitch.TargetSwitchCooldown and Target and Target.Character then
        local character = Target.Character
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        
        if humanoid and humanoid.Health > 0 and rootPart then
            local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
            if distance <= Settings.MaxDistance and (not Settings.VisibilityCheck or IsVisible(character)) then
                return Target  -- Keep current target during cooldown
            end
        end
    end
    
    -- Evaluate all potential targets
    local potentialTargets = {}
    
    for _, player in ipairs(cachedPlayers) do
        if Settings.TeamCheck and player.Team == LocalPlayer.Team then continue end
        
        local character = player.Character
        if not character then continue end
        
        local humanoid = character:FindFirstChildOfClass("Humanoid")
        if not humanoid or humanoid.Health <= 0 then continue end
        
        local rootPart = character:FindFirstChild("HumanoidRootPart")
        if not rootPart then continue end
        
        -- Check distance
        local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
        if distance > Settings.MaxDistance then continue end
        
        -- Check if target is within anticipation range even if not visible
        local isVisible = IsVisible(character)
        
        if isVisible then
            recentTargets[player] = currentTime
        elseif distance > 150 then
            continue
        end
        
        -- Calculate threat level
        local threatLevel = EvaluateThreatLevel(player)
        
        -- Add to potential targets
        table.insert(potentialTargets, {
            Player = player,
            Threat = threatLevel,
            Distance = distance,
            IsVisible = isVisible
        })
    end
    
    -- Sort by threat level (highest first)
    table.sort(potentialTargets, function(a, b)
        -- Prioritize visible targets with similar threat levels
        if a.IsVisible and not b.IsVisible and a.Threat > b.Threat * 0.7 then
            return true
        elseif b.IsVisible and not a.IsVisible and b.Threat > a.Threat * 0.7 then
            return false
        end
        
        -- Otherwise sort by threat level
        return a.Threat > b.Threat
    end)
    
    -- Select the best target with minimum threat difference requirement
    if #potentialTargets > 0 then
        local topThreat = potentialTargets[1].Threat
        
        -- Check if we should switch from current target
        if Target and Target.Character then
            local currentThreat = EvaluateThreatLevel(Target)
            
            -- Only switch if new target has significantly higher threat
            if topThreat > currentThreat + Settings.SmartSwitch.MinThreatDifference then
                bestTarget = potentialTargets[1].Player
                highestThreat = topThreat
            else
                -- Keep current target if threat difference is small
                bestTarget = Target
                highestThreat = currentThreat
            end
        else
            -- No current target, select the best one
            bestTarget = potentialTargets[1].Player
            highestThreat = topThreat
        end
    end
    
    -- If we're switching targets, update the cooldown
    if bestTarget and bestTarget ~= Target then
        lastTargetSwitch = currentTime
        targetLockTime = currentTime
        
        -- Update playstyle metrics for target switching
        playstyleMetrics.recentTargets[bestTarget] = currentTime
        
        -- Update preferred targets (learning)
        if not playstyleMetrics.preferredTargets[bestTarget] then
            playstyleMetrics.preferredTargets[bestTarget] = 0
        end
        playstyleMetrics.preferredTargets[bestTarget] = playstyleMetrics.preferredTargets[bestTarget] + 
            Settings.PlaystyleAdaptation.LearningRate
    end
    
    -- Update threat label even when no target is found
    if threatLabel then
        if bestTarget then
            threatLabel.Text = "⚠️ Threat Level: " .. math.floor(highestThreat)
            
            -- Color code threat level
            if highestThreat > 200 then
                threatLabel.TextColor3 = PremiumColors.Danger
            elseif highestThreat > 120 then
                threatLabel.TextColor3 = Color3.fromRGB(255, 80, 80)
            elseif highestThreat > 80 then
                threatLabel.TextColor3 = Color3.fromRGB(255, 160, 0)
            elseif highestThreat > 50 then
                threatLabel.TextColor3 = PremiumColors.Accent
            elseif highestThreat > 30 then
                threatLabel.TextColor3 = PremiumColors.Light
            else
                threatLabel.TextColor3 = PremiumColors.Secondary
            end
        else
            threatLabel.Text = "⚠️ Threat Level: 0"
            threatLabel.TextColor3 = PremiumColors.Light
        end
    end
    
    return bestTarget
end

-- Smooth Aiming System
local function SmoothAim(targetPosition)
    local currentCFrame = Camera.CFrame
    local targetCFrame = CFrame.new(currentCFrame.Position, targetPosition)
    
    TweenService:Create(Camera, TweenInfo.new(Settings.Sensitivity, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {
        CFrame = targetCFrame
    }):Play()
end

-- Fixed Radar System with forward-facing orientation
local function CreateRadar()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "VenomRadar_" .. math.random(10000, 99999)
    screenGui.Parent = game.CoreGui
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    
    -- Main radar frame
    radarFrame = Instance.new("Frame")
    radarFrame.Size = UDim2.new(0, Settings.Radar.Size, 0, Settings.Radar.Size)
    radarFrame.Position = Settings.Radar.Position
    radarFrame.BackgroundColor3 = PremiumColors.Background
    radarFrame.BackgroundTransparency = Settings.Radar.BackgroundTransparency
    radarFrame.BorderSizePixel = 0
    radarFrame.Active = true
    radarFrame.Draggable = true
    
    -- Radar border with premium glow
    local radarBorder = Instance.new("UIStroke")
    radarBorder.Color = PremiumColors.Primary
    radarBorder.Thickness = 2
    radarBorder.Parent = radarFrame
    
    -- Animate the border
    local borderTween = TweenService:Create(radarBorder, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Color = PremiumColors.Secondary
    })
    borderTween:Play()
    
    -- Radar corner
    local radarCorner = Instance.new("UICorner")
    radarCorner.CornerRadius = UDim.new(1, 0)
    radarCorner.Parent = radarFrame
    
    -- Radar grid lines
    local gridLines = {
        {From = UDim2.new(0.5, 0, 0, 0), To = UDim2.new(0.5, 0, 1, 0)},
        {From = UDim2.new(0, 0, 0.5, 0), To = UDim2.new(1, 0, 0.5, 0)},
    }
    
    for _, line in ipairs(gridLines) do
        local lineFrame = Instance.new("Frame")
        lineFrame.Size = UDim2.new(0, 1, 0, 1)
        lineFrame.Position = line.From
        lineFrame.AnchorPoint = Vector2.new(0.5, 0.5)
        lineFrame.BackgroundColor3 = PremiumColors.Primary
        lineFrame.BackgroundTransparency = 0.7
        lineFrame.BorderSizePixel = 0
        lineFrame.Parent = radarFrame
        
        local lineTween = TweenService:Create(lineFrame, TweenInfo.new(0.5), {
            Size = line.To
        })
        lineTween:Play()
    end
    
    -- Player dot (self)
    local selfDot = Instance.new("Frame")
    selfDot.Size = UDim2.new(0, 6, 0, 6)
    selfDot.Position = UDim2.new(0.5, -3, 0.5, -3)
    selfDot.BackgroundColor3 = PremiumColors.Primary
    selfDot.BorderSizePixel = 0
    selfDot.ZIndex = 3
    selfDot.Parent = radarFrame
    
    local selfDotCorner = Instance.new("UICorner")
    selfDotCorner.CornerRadius = UDim.new(1, 0)
    selfDotCorner.Parent = selfDot
    
    -- Add pulsing animation to self dot
    local pulseTween = TweenService:Create(selfDot, TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Size = UDim2.new(0, 8, 0, 8),
        Position = UDim2.new(0.5, -4, 0.5, -4)
    })
    pulseTween:Play()
    
    -- Radar range indicator
    local rangeLabel = Instance.new("TextLabel")
    rangeLabel.Size = UDim2.new(1, 0, 0, 15)
    rangeLabel.Position = UDim2.new(0, 0, 1, 5)
    rangeLabel.Text = "Range: " .. Settings.Radar.Range .. " studs"
    rangeLabel.BackgroundTransparency = 1
    rangeLabel.TextColor3 = PremiumColors.Light
    rangeLabel.Font = Enum.Font.GothamBold
    rangeLabel.TextSize = 10
    rangeLabel.TextXAlignment = Enum.TextXAlignment.Center
    rangeLabel.Parent = radarFrame
    
    radarFrame.Parent = screenGui
    return screenGui
end

local function UpdateRadar()
    if not Settings.Radar.Enabled or not radarFrame then return end
    
    -- Optimize refresh rate to reduce lag
    local currentTime = tick()
    if currentTime - lastRadarUpdate < Settings.Radar.RefreshRate then return end
    lastRadarUpdate = currentTime
    
    -- Clear previous dots
    for playerName, dot in pairs(radarDots) do
        if dot and dot.Parent then
            dot:Destroy()
        end
    end
    radarDots = {}
    
    -- Get player positions and update radar
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character then
            local character = player.Character
            local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            
            if humanoidRootPart and humanoid and humanoid.Health > 0 then
                -- Calculate position relative to local player
                local localRoot = LocalPlayer.Character and LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
                if not localRoot then continue end
                
                local position = humanoidRootPart.Position
                local localPosition = localRoot.Position
                
                -- Calculate direction and distance
                local direction = position - localPosition
                local distance = direction.Magnitude
                
                -- Skip if beyond radar range
                if distance > Settings.Radar.Range then continue end
                
                -- Calculate radar position (normalized to radar size)
                local normalizedDistance = distance / Settings.Radar.Range
                
                -- FIXED: Always face forward relative to player (not camera)
                local playerRotation = localRoot.CFrame - localRoot.CFrame.Position
                local forwardVector = playerRotation.LookVector
                
                -- Calculate angle from player forward to target
                local flatDirection = Vector3.new(direction.X, 0, direction.Z).Unit
                local flatForward = Vector3.new(forwardVector.X, 0, forwardVector.Z).Unit
                
                local angle = math.atan2(flatDirection.X, flatDirection.Z) - math.atan2(flatForward.X, flatForward.Z)
                
                -- Convert to radar coordinates
                local radarX = 0.5 + math.sin(angle) * normalizedDistance * 0.5
                local radarY = 0.5 - math.cos(angle) * normalizedDistance * 0.5
                
                -- Create or update radar dot
                local dot = Instance.new("Frame")
                dot.Size = UDim2.new(0, 8, 0, 8)
                dot.Position = UDim2.new(radarX, -4, radarY, -4)
                dot.AnchorPoint = Vector2.new(0.5, 0.5)
                dot.BorderSizePixel = 0
                dot.ZIndex = 2
                
                -- Color code based on threat level
                local threatLevel = EvaluateThreatLevel(player)
                local dotColor
                
                if threatLevel > 200 then
                    dotColor = PremiumColors.Danger
                elseif threatLevel > 120 then
                    dotColor = Color3.fromRGB(255, 80, 80)
                elseif threatLevel > 80 then
                    local ratio = (threatLevel - 80) / 40
                    dotColor = Color3.fromRGB(255, 160, 0):Lerp(Color3.fromRGB(255, 80, 80), ratio)
                elseif threatLevel > 50 then
                    local ratio = (threatLevel - 50) / 30
                    dotColor = PremiumColors.Accent:Lerp(Color3.fromRGB(255, 160, 0), ratio)
                elseif threatLevel > 30 then
                    local ratio = (threatLevel - 30) / 20
                    dotColor = PremiumColors.Light:Lerp(PremiumColors.Accent, ratio)
                else
                    dotColor = PremiumColors.Secondary
                end
                
                dot.BackgroundColor3 = dotColor
                
                -- Add corner to make it circular
                local dotCorner = Instance.new("UICorner")
                dotCorner.CornerRadius = UDim.new(1, 0)
                dotCorner.Parent = dot
                
                -- Add glow effect for high threat targets
                if threatLevel > 80 then
                    local glow = Instance.new("UIStroke")
                    glow.Color = dotColor
                    glow.Thickness = 2
                    glow.Transparency = 0.5
                    glow.Parent = dot
                    
                    -- Animate the glow
                    local glowTween = TweenService:Create(glow, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
                        Thickness = 3
                    })
                    glowTween:Play()
                end
                
                -- Add player name tooltip
                local tooltip = Instance.new("TextLabel")
                tooltip.Size = UDim2.new(0, 0, 0, 0)
                tooltip.Position = UDim2.new(0.5, 0, 0, -15)
                tooltip.Text = player.Name
                tooltip.BackgroundTransparency = 1
                tooltip.TextColor3 = PremiumColors.Light
                tooltip.Font = Enum.Font.GothamBold
                tooltip.TextSize = 10
                tooltip.TextXAlignment = Enum.TextXAlignment.Center
                tooltip.Visible = false
                tooltip.Parent = dot
                
                -- Show tooltip on mouse enter
                dot.MouseEnter:Connect(function()
                    tooltip.Size = UDim2.new(0, 60, 0, 15)
                    tooltip.Position = UDim2.new(0.5, -30, 0, -18)
                    tooltip.Visible = true
                end)
                
                dot.MouseLeave:Connect(function()
                    tooltip.Visible = false
                end)
                
                dot.Parent = radarFrame
                radarDots[player.Name] = dot
            end
        end
    end
end

-- Input Handling
UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Settings.AimKey then
        Holding = true
        if Settings.FOVChangeOnAim then
            FOVCircle.Radius = Settings.FOV.Radius * 0.6
        end
    end
    
    if input.KeyCode == Settings.ToggleKey then
        Settings.Enabled = not Settings.Enabled
        UpdateUI()
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Settings.AimKey then
        Holding = false
        TargetIndicator.Visible = false
        LockIndicator.Visible = false
        if Settings.FOVChangeOnAim then
            FOVCircle.Radius = Settings.FOV.Radius
        end
    end
end)

-- Track damage taken for threat assessment
local function TrackDamage()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end
    
    humanoid.HealthChanged:Connect(function()
        if humanoid.Health < humanoid.MaxHealth then
            -- Try to find who damaged us
            for _, player in ipairs(Players:GetPlayers()) do
                if player ~= LocalPlayer and player.Character then
                    local tool = player.Character:FindFirstChildOfClass("Tool")
                    if tool then
                        RecordCombatEvent(player, humanoid.MaxHealth - humanoid.Health)
                        lastDamageTaken = tick()
                        damageSource = player
                        break
                    end
                end
            end
        end
    end)
end

-- Track when player fires a weapon
local function TrackWeaponFire()
    local character = LocalPlayer.Character
    if not character then return end
    
    -- Check for tool added (weapon equipped)
    character.ChildAdded:Connect(function(child)
        if child:IsA("Tool") then
            -- Listen for when the tool is activated (fired)
            child.Activated:Connect(function()
                playstyleMetrics.lastShotTime = tick()
                playstyleMetrics.lastCombatTime = tick()
                playstyleMetrics.combatActions = playstyleMetrics.combatActions + 1
            end)
        end
    end)
end

-- Premium UI with scrolling frame for buttons
local function CreatePremiumUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "VenomReptilePremiumUI_" .. math.random(10000, 99999)
    screenGui.Parent = game.CoreGui
    screenGui.ResetOnSpawn = false
    screenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

    -- Main container with premium design
    local mainFrame = Instance.new("Frame")
    mainFrame.Size = UDim2.new(0, 320, 0, 400)
    mainFrame.Position = UDim2.new(0, 10, 0, 10)
    mainFrame.BackgroundColor3 = PremiumColors.Background
    mainFrame.BorderSizePixel = 0
    mainFrame.Active = true
    mainFrame.Draggable = true

    -- Premium background pattern
    local pattern = Instance.new("ImageLabel")
    pattern.Size = UDim2.new(1, 0, 1, 0)
    pattern.Position = UDim2.new(0, 0, 0, 0)
    pattern.Image = "rbxassetid://11543912338"
    pattern.ImageTransparency = 0.1
    pattern.ScaleType = Enum.ScaleType.Tile
    pattern.TileSize = UDim2.new(0, 100, 0, 100)
    pattern.BackgroundTransparency = 1
    pattern.Parent = mainFrame

    -- Premium border with glow effect
    local borderGlow = Instance.new("Frame")
    borderGlow.Size = UDim2.new(1, 6, 1, 6)
    borderGlow.Position = UDim2.new(0, -3, 0, -3)
    borderGlow.BackgroundColor3 = PremiumColors.Primary
    borderGlow.BorderSizePixel = 0
    borderGlow.ZIndex = 0
    
    local glowCorner = Instance.new("UICorner")
    glowCorner.CornerRadius = UDim.new(0, 12)
    glowCorner.Parent = borderGlow
    
    local glowGradient = Instance.new("UIGradient")
    glowGradient.Color = ColorSequence.new({
        ColorSequenceKeypoint.new(0, PremiumColors.Primary),
        ColorSequenceKeypoint.new(1, PremiumColors.Secondary)
    })
    glowGradient.Rotation = 45
    glowGradient.Parent = borderGlow
    
    -- Animate the glow
    local glowTween = TweenService:Create(glowGradient, TweenInfo.new(2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Rotation = 405
    })
    glowTween:Play()

    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 10)
    corner.Parent = mainFrame

    -- Premium title bar with animated pattern
    local titleBar = Instance.new("Frame")
    titleBar.Size = UDim2.new(1, 0, 0, 40)
    titleBar.Position = UDim2.new(0, 0, 0, 0)
    titleBar.BackgroundColor3 = PremiumColors.Primary
    titleBar.BorderSizePixel = 0
    titleBar.ZIndex = 2

    local titlePattern = Instance.new("ImageLabel")
    titlePattern.Size = UDim2.new(1, 0, 1, 0)
    titlePattern.Image = "rbxassetid://11543914562"
    titlePattern.ImageTransparency = 0.2
    titlePattern.ScaleType = Enum.ScaleType.Tile
    titlePattern.TileSize = UDim2.new(0, 50, 0, 50)
    titlePattern.BackgroundTransparency = 1
    titlePattern.Parent = titleBar

    local titleCorner = Instance.new("UICorner")
    titleCorner.CornerRadius = UDim.new(0, 10)
    titleCorner.Parent = titleBar

    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -40, 1, 0)
    title.Position = UDim2.new(0, 15, 0, 0)
    title.Text = "🐍 VENOM REPTILE v7.5 ULTIMATE"
    title.BackgroundTransparency = 1
    title.TextColor3 = Color3.fromRGB(255, 255, 255)
    title.Font = Enum.Font.GothamBlack
    title.TextSize = 16
    title.TextXAlignment = Enum.TextXAlignment.Left
    title.ZIndex = 3

    local statusLight = Instance.new("Frame")
    statusLight.Size = UDim2.new(0, 10, 0, 10)
    statusLight.Position = UDim2.new(1, -25, 0.5, -5)
    statusLight.BackgroundColor3 = PremiumColors.Success
    statusLight.BorderSizePixel = 0
    statusLight.ZIndex = 3

    local statusCorner = Instance.new("UICorner")
    statusCorner.CornerRadius = UDim.new(1, 0)
    statusCorner.Parent = statusLight

    -- Add pulsing animation to status light
    local pulseTween = TweenService:Create(statusLight, TweenInfo.new(0.8, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Size = UDim2.new(0, 12, 0, 12),
        Position = UDim2.new(1, -26, 0.5, -6)
    })
    pulseTween:Play()

    -- Scrolling frame for buttons
    local scrollFrame = Instance.new("ScrollingFrame")
    scrollFrame.Size = UDim2.new(1, 0, 1, -190)
    scrollFrame.Position = UDim2.new(0, 0, 0, 40)
    scrollFrame.BackgroundTransparency = 1
    scrollFrame.BorderSizePixel = 0
    scrollFrame.ScrollBarThickness = 4
    scrollFrame.ScrollBarImageColor3 = PremiumColors.Primary
    scrollFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
    scrollFrame.AutomaticCanvasSize = Enum.AutomaticSize.Y

    -- Premium control buttons with hover effects
    local buttons = {
        {Name = "Toggle", Text = "TOGGLE AIMBOT (F)", Key = "Enabled", OnColor = PremiumColors.Primary, OffColor = PremiumColors.Danger},
        {Name = "Prediction", Text = "PREDICTION", Key = "Prediction.Enabled", OnColor = PremiumColors.Secondary, OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "WallCheck", Text = "WALL CHECK", Key = "VisibilityCheck", OnColor = PremiumColors.Accent, OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "TeamCheck", Text = "TEAM CHECK", Key = "TeamCheck", OnColor = PremiumColors.Light, OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "Humanizer", Text = "BODY RANDOMIZER", Key = "Humanizer.Enabled", OnColor = PremiumColors.Success, OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "SmartSwitch", Text = "SMART SWITCH", Key = "SmartSwitch.Enabled", OnColor = PremiumColors.Elite, OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "Radar", Text = "RADAR SYSTEM", Key = "Radar.Enabled", OnColor = Color3.fromRGB(0, 180, 255), OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "Adaptation", Text = "PLAYSTYLE ADAPTATION", Key = "PlaystyleAdaptation.Enabled", OnColor = Color3.fromRGB(0, 200, 200), OffColor = Color3.fromRGB(60, 60, 60)},
        {Name = "DynamicFOV", Text = "ADAPTIVE FOV", Key = "DynamicFOVSettings.Enabled", OnColor = Color3.fromRGB(100, 200, 255), OffColor = Color3.fromRGB(60, 60, 60)}
    }

    local buttonInstances = {}
    local yOffset = 5

    for i, btn in ipairs(buttons) do
        local buttonContainer = Instance.new("Frame")
        buttonContainer.Size = UDim2.new(0.9, 0, 0, 40)
        buttonContainer.Position = UDim2.new(0.05, 0, 0, yOffset)
        buttonContainer.BackgroundTransparency = 1
        
        local button = Instance.new("TextButton")
        button.Size = UDim2.new(1, 0, 1, 0)
        button.Text = btn.Text
        button.BackgroundColor3 = Settings.Enabled and btn.OnColor or btn.OffColor
        button.TextColor3 = Color3.fromRGB(255, 255, 255)
        button.Font = Enum.Font.GothamBold
        button.TextSize = 12
        button.AutoButtonColor = false
        
        -- Premium button styling
        local buttonCorner = Instance.new("UICorner")
        buttonCorner.CornerRadius = UDim.new(0, 8)
        buttonCorner.Parent = button

        -- Add premium gradient to buttons
        local buttonGradient = Instance.new("UIGradient")
        buttonGradient.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, btn.OnColor),
            ColorSequenceKeypoint.new(1, btn.OnColor:Lerp(Color3.fromRGB(255, 255, 255), 0.1))
        })
        buttonGradient.Rotation = 90
        buttonGradient.Parent = button

        -- Add subtle pattern to buttons
        local buttonPattern = Instance.new("ImageLabel")
        buttonPattern.Size = UDim2.new(1, 0, 1, 0)
        buttonPattern.Image = "rbxassetid://11543917824"
        buttonPattern.ImageTransparency = 0.8
        buttonPattern.BackgroundTransparency = 1
        buttonPattern.Parent = button

        -- Add glow effect on hover
        local buttonGlow = Instance.new("Frame")
        buttonGlow.Size = UDim2.new(1, 6, 1, 6)
        buttonGlow.Position = UDim2.new(0, -3, 0, -3)
        buttonGlow.BackgroundColor3 = btn.OnColor
        buttonGlow.BorderSizePixel = 0
        buttonGlow.ZIndex = -1
        buttonGlow.Visible = false
        
        local glowCorner = Instance.new("UICorner")
        glowCorner.CornerRadius = UDim.new(0, 10)
        glowCorner.Parent = buttonGlow
        
        buttonGlow.Parent = buttonContainer
        
        button.MouseEnter:Connect(function()
            if button.BackgroundColor3 ~= btn.OffColor then
                buttonGlow.Visible = true
                TweenService:Create(button, TweenInfo.new(0.2), {
                    Size = UDim2.new(1, 4, 1, 4),
                    Position = UDim2.new(0, -2, 0, -2)
                }):Play()
            end
        end)
        
        button.MouseLeave:Connect(function()
            buttonGlow.Visible = false
            TweenService:Create(button, TweenInfo.new(0.2), {
                Size = UDim2.new(1, 0, 1, 0),
                Position = UDim2.new(0, 0, 0, 0)
            }):Play()
        end)

        button.MouseButton1Click:Connect(function()
            local keys = string.split(btn.Key, ".")
            local current = Settings
            for i = 1, #keys - 1 do
                current = current[keys[i]]
            end
            current[keys[#keys]] = not current[keys[#keys]]
            
            -- Special handling for radar
            if btn.Name == "Radar" then
                if Settings.Radar.Enabled then
                    CreateRadar()
                elseif radarFrame then
                    radarFrame.Parent:Destroy()
                    radarFrame = nil
                end
            end
            
            UpdateUI()
        end)

        buttonInstances[btn.Name] = button
        button.Parent = buttonContainer
        buttonContainer.Parent = scrollFrame
        yOffset = yOffset + 45
    end

    -- Premium stats panel with animated elements
    local statsPanel = Instance.new("Frame")
    statsPanel.Size = UDim2.new(0.9, 0, 0, 150)
    statsPanel.Position = UDim2.new(0.05, 0, 1, -160)
    statsPanel.BackgroundColor3 = PremiumColors.Panel
    statsPanel.BorderSizePixel = 0

    local statsCorner = Instance.new("UICorner")
    statsCorner.CornerRadius = UDim.new(0, 8)
    statsCorner.Parent = statsPanel

    -- Add animated border to stats panel
    local statsBorder = Instance.new("UIStroke")
    statsBorder.Color = PremiumColors.Primary
    statsBorder.Thickness = 2
    statsBorder.Parent = statsPanel
    
    -- Animate the border
    local borderTween = TweenService:Create(statsBorder, TweenInfo.new(3, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut, -1, true), {
        Color = PremiumColors.Secondary
    })
    borderTween:Play()

    -- Add pattern to stats panel
    local statsPattern = Instance.new("ImageLabel")
    statsPattern.Size = UDim2.new(1, 0, 1, 0)
    statsPattern.Image = "rbxassetid://11543919876"
    statsPattern.ImageTransparency = 0.9
    statsPattern.BackgroundTransparency = 1
    statsPattern.Parent = statsPanel

    local targetLabel = Instance.new("TextLabel")
    targetLabel.Size = UDim2.new(1, -10, 0, 22)
    targetLabel.Position = UDim2.new(0, 10, 0, 10)
    targetLabel.Text = "🎯 Target: None"
    targetLabel.BackgroundTransparency = 1
    targetLabel.TextColor3 = PremiumColors.Light
    targetLabel.Font = Enum.Font.GothamBold
    targetLabel.TextSize = 12
    targetLabel.TextXAlignment = Enum.TextXAlignment.Left

    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -10, 0, 22)
    statusLabel.Position = UDim2.new(0, 10, 0, 32)
    statusLabel.Text = "📊 Status: Ready"
    statusLabel.BackgroundTransparency = 1
    statusLabel.TextColor3 = PremiumColors.Light
    statusLabel.Font = Enum.Font.GothamBold
    statusLabel.TextSize = 12
    statusLabel.TextXAlignment = Enum.TextXAlignment.Left

    local fpsLabel = Instance.new("TextLabel")
    fpsLabel.Size = UDim2.new(1, -10, 0, 22)
    fpsLabel.Position = UDim2.new(0, 10, 0, 54)
    fpsLabel.Text = "⚡ FPS: 60"
    fpsLabel.BackgroundTransparency = 1
    fpsLabel.TextColor3 = PremiumColors.Light
    fpsLabel.Font = Enum.Font.GothamBold
    fpsLabel.TextSize = 12
    fpsLabel.TextXAlignment = Enum.TextXAlignment.Left

    local threatLabel = Instance.new("TextLabel")
    threatLabel.Size = UDim2.new(1, -10, 0, 22)
    threatLabel.Position = UDim2.new(0, 10, 0, 76)
    threatLabel.Text = "⚠️ Threat Level: 0"
    threatLabel.BackgroundTransparency = 1
    threatLabel.TextColor3 = PremiumColors.Light
    threatLabel.Font = Enum.Font.GothamBold
    threatLabel.TextSize = 12
    threatLabel.TextXAlignment = Enum.TextXAlignment.Left

    local distanceLabel = Instance.new("TextLabel")
    distanceLabel.Size = UDim2.new(1, -10, 0, 22)
    distanceLabel.Position = UDim2.new(0, 10, 0, 98)
    distanceLabel.Text = "📏 Distance: 0 studs"
    distanceLabel.BackgroundTransparency = 1
    distanceLabel.TextColor3 = PremiumColors.Light
    distanceLabel.Font = Enum.Font.GothamBold
    distanceLabel.TextSize = 12
    distanceLabel.TextXAlignment = Enum.TextXAlignment.Left

    local playstyleLabel = Instance.new("TextLabel")
    playstyleLabel.Size = UDim2.new(1, -10, 0, 22)
    playstyleLabel.Position = UDim2.new(0, 10, 0, 120)
    playstyleLabel.Text = "🎭 Mode: Stealth"
    playstyleLabel.BackgroundTransparency = 1
    playstyleLabel.TextColor3 = PremiumColors.Light
    playstyleLabel.Font = Enum.Font.GothamBold
    playstyleLabel.TextSize = 12
    playstyleLabel.TextXAlignment = Enum.TextXAlignment.Left

    -- Assembly
    borderGlow.Parent = mainFrame
    titleBar.Parent = mainFrame
    title.Parent = titleBar
    statusLight.Parent = titleBar
    scrollFrame.Parent = mainFrame
    statsPanel.Parent = mainFrame
    targetLabel.Parent = statsPanel
    statusLabel.Parent = statsPanel
    fpsLabel.Parent = statsPanel
    threatLabel.Parent = statsPanel
    distanceLabel.Parent = statsPanel
    playstyleLabel.Parent = statsPanel
    mainFrame.Parent = screenGui

    return {
        Main = mainFrame,
        Buttons = buttonInstances,
        StatusLight = statusLight,
        TargetLabel = targetLabel,
        StatusLabel = statusLabel,
        FPSLabel = fpsLabel,
        ThreatLabel = threatLabel,
        DistanceLabel = distanceLabel,
        PlaystyleLabel = playstyleLabel,
        ButtonColors = buttons
    }
end

-- Initialize Premium UI
local UI = CreatePremiumUI()
threatLabel = UI.ThreatLabel

-- Enhanced UI Update Function with visual feedback
function UpdateUI()
    UI.StatusLight.BackgroundColor3 = Settings.Enabled and PremiumColors.Success or PremiumColors.Danger
    
    -- Update playstyle label with more accurate detection
    if playstyleMetrics.isStealthMode then
        UI.PlaystyleLabel.Text = "🎭 Mode: Stealth (" .. math.floor(playstyleMetrics.detectionLevel * 100) .. "% detected)"
        UI.PlaystyleLabel.TextColor3 = Color3.fromRGB(100, 200, 255)
    else
        UI.PlaystyleLabel.Text = "🎭 Mode: Combat (" .. math.floor(playstyleMetrics.detectionLevel * 100) .. "% detected)"
        UI.PlaystyleLabel.TextColor3 = PremiumColors.Danger
    end
    
    for name, button in pairs(UI.Buttons) do
        local btnData
        for _, data in ipairs(UI.ButtonColors) do
            if data.Name == name then
                btnData = data
                break
            end
        end
        
        if btnData then
            local value = Settings
            local keys = string.split(btnData.Key, ".")
            for _, key in ipairs(keys) do
                value = value[key]
            end
            
            button.BackgroundColor3 = value and btnData.OnColor or btnData.OffColor
            
            -- Update button gradient
            local gradient = button:FindFirstChildOfClass("UIGradient")
            if gradient then
                gradient.Color = ColorSequence.new({
                    ColorSequenceKeypoint.new(0, value and btnData.OnColor or btnData.OffColor),
                    ColorSequenceKeypoint.new(1, (value and btnData.OnColor or btnData.OffColor):Lerp(Color3.fromRGB(255, 255, 255), 0.1))
                })
            end
            
            -- Add checkmark indicator for ON state with fun emojis
            if value then
                if name == "Humanizer" then
                    button.Text = "🎯 " .. btnData.Text
                elseif name == "SmartSwitch" then
                    button.Text = "🔄 " .. btnData.Text
                elseif name == "Prediction" then
                    button.Text = "🔮 " .. btnData.Text
                elseif name == "Radar" then
                    button.Text = "📡 " .. btnData.Text
                elseif name == "Adaptation" then
                    button.Text = "🧠 " .. btnData.Text
                elseif name == "DynamicFOV" then
                    button.Text = "👁️ " .. btnData.Text
                else
                    button.Text = "✓ " .. btnData.Text
                end
            else
                button.Text = "✗ " .. btnData.Text
            end
        end
    end
end

-- FPS Counter
RunService.Heartbeat:Connect(function()
    frameCount = frameCount + 1
    if tick() - lastFPSUpdate >= 1 then
        currentFPS = math.floor(frameCount / (tick() - lastFPSUpdate))
        frameCount = 0
        lastFPSUpdate = tick()
        
        if UI then
            UI.FPSLabel.Text = "⚡ FPS: " .. currentFPS
        end
    end
end)

-- Enhanced main loop with all systems integrated
RunService.RenderStepped:Connect(function()
    FOVCircle.Position = UserInputService:GetMouseLocation()
    FOVCircle.Visible = Settings.FOV.Visible
    
    -- Update adaptive FOV
    UpdateAdaptiveFOV()
    
    -- Update radar if enabled
    if Settings.Radar.Enabled then
        UpdateRadar()
    end
    
    if Holding and Settings.Enabled then
        Target = FindOptimalTarget()
        
        if Target and Target.Character then
            local aimPart, partOffset = GetRandomizedAimPart(Target.Character)
            if aimPart then
                -- Update UI
                UI.TargetLabel.Text = "🎯 Target: " .. Target.Name
                UI.StatusLabel.Text = "📊 Status: Locked 🔒"
                
                -- Update playstyle metrics
                playstyleMetrics.lastCombatTime = tick()
                
                -- Update distance label
                local rootPart = Target.Character:FindFirstChild("HumanoidRootPart")
                if rootPart then
                    local distance = (rootPart.Position - Camera.CFrame.Position).Magnitude
                    UI.DistanceLabel.Text = "📏 Distance: " .. math.floor(distance) .. " studs"
                    
                    -- Update engagement distance average
                    if playstyleMetrics.engagementCount < 100 then
                        playstyleMetrics.engagementCount = playstyleMetrics.engagementCount + 1
                    end
                    playstyleMetrics.averageEngagementDistance = 
                        (playstyleMetrics.averageEngagementDistance * (playstyleMetrics.engagementCount - 1) + distance) / 
                        playstyleMetrics.engagementCount
                end
                
                -- Update target indicator
                if Settings.Highlight.Enabled then
                    local screenPoint = Camera:WorldToViewportPoint(aimPart.Position)
                    TargetIndicator.Position = Vector2.new(screenPoint.X, screenPoint.Y)
                    TargetIndicator.Visible = true
                    
                    -- Update lock indicator
                    LockIndicator.Position = Vector2.new(screenPoint.X, screenPoint.Y)
                    LockIndicator.Visible = true
                    
                    -- Animate lock indicator
                    LockIndicator.Radius = 16 + math.sin(tick() * 5) * 2
                end
                
                -- Calculate and apply aim
                local targetPos = CalculatePrediction(Target.Character, aimPart)
                if partOffset then
                    targetPos = targetPos + partOffset
                end
                targetPos = ApplyHumanizer(targetPos, tick(), Target.Character, aimPart)
                
                SmoothAim(targetPos)
                
                LastTargetTime = tick()
            end
        else
            UI.TargetLabel.Text = "🎯 Target: None"
            UI.StatusLabel.Text = "📊 Status: Searching..."
            UI.DistanceLabel.Text = "📏 Distance: 0 studs"
            TargetIndicator.Visible = false
            LockIndicator.Visible = false
        end
    else
        UI.StatusLabel.Text = "📊 Status: Ready"
        if tick() - LastTargetTime > 0.5 then
            UI.TargetLabel.Text = "🎯 Target: None"
            UI.DistanceLabel.Text = "📏 Distance: 0 studs"
        end
        TargetIndicator.Visible = false
        LockIndicator.Visible = false
    end
    
    -- Update UI periodically
    if tick() % 1 < 0.05 then
        UpdateUI()
    end
end)

-- Initialization
TrackDamage()
TrackWeaponFire()
UpdateUI()
if Settings.Radar.Enabled then
    CreateRadar()
end

print("🐍 Venom Reptile v7.5 Ultimate Premium Loaded!")
print("🎯 REALISTIC Threat System | Perfect Stealth/Combat Detection")
print("🧠 Advanced Playstyle Adaptation | Movement-Based Detection")
print("👁️  Intelligent Adaptive FOV | Performance & Engagement Based")
print("🔧 Press F to toggle | Right-click to aim")
print("📡 Radar with 300 stud range and proper forward orientation")
print("🎯 Smart threat system prevents rapid switching between similar threats")
print("⚡ Target locking with minimum threat difference requirement")
print("💥 Enhanced combat awareness with realistic detection")
